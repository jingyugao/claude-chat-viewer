#!/bin/bash

# 获取脚本所在目录的绝对路径，用于定位项目根目录
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# 检查参数
if [ -z "$1" ]; then
  echo "用法: $0 <session名称>"
  echo "示例: $0 my-session"
  exit 1
fi

SESSION_NAME="$1"
# 路径更新为 sessions/ 目录
OUTPUT_MITM="$PROJECT_ROOT/sessions/${SESSION_NAME}.mitm"
OUTPUT_JSON="$PROJECT_ROOT/sessions/${SESSION_NAME}.json"

# 动态获取一个随机可用端口
PROXY_PORT=$(python3 -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()')
CERT_PATH="$HOME/.mitmproxy/mitmproxy-ca-cert.pem"

# 检查证书是否存在
if [ ! -f "$CERT_PATH" ]; then
  echo "错误: 未找到 CA 证书: $CERT_PATH"
  echo "请先运行一次 'mitmproxy' 以生成证书。"
  exit 1
fi

# 确保 sessions 目录存在
mkdir -p "$PROJECT_ROOT/sessions"

echo "正在启动抓包代理 (端口 $PROXY_PORT)..."
echo "数据将实时保存到: $OUTPUT_JSON"
echo ""

# 设置环境变量，让 parser.py 知道输出路径
export OUTPUT_JSON_PATH="$OUTPUT_JSON"

# 后台启动 mitmdump，使用 parser.py 脚本实现实时保存
mitmdump -p $PROXY_PORT -s "$PROJECT_ROOT/src/parser.py" -w "$OUTPUT_MITM" &
MITM_PID=$!

# 确保脚本退出时清理代理进程和临时文件
cleanup() {
  kill $MITM_PID 2>/dev/null
  [ -n "$TEMP_RC" ] && rm -f "$TEMP_RC"
  [ -n "$TEMP_DIR" ] && rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# 等待代理完全启动
sleep 2

echo "✅ 抓包代理已启动！"
echo ""
echo "╔════════════════════════════════════════════════════════════════╗"
echo "║  🔴 正在录制 API 调用                                          ║"
echo "║                                                                ║"
echo "║  📝 Session: ${SESSION_NAME}"
echo "║  💾 实时保存: ${OUTPUT_JSON}"
echo "║  📊 查看地址: http://localhost:8088/?file=${SESSION_NAME}.json"
echo "║                                                                ║"
echo "║  ▶️  现在可以运行: claude                                      ║"
echo "║  ⏹️  完成后输入: exit 或按 Ctrl+D                             ║"
echo "╚════════════════════════════════════════════════════════════════╝"
echo ""

# 启动一个新的 shell，自动继承环境变量
export HTTP_PROXY="http://127.0.0.1:$PROXY_PORT"
export HTTPS_PROXY="http://127.0.0.1:$PROXY_PORT"
export NODE_EXTRA_CA_CERTS="$CERT_PATH"

# 检测当前使用的 shell
CURRENT_SHELL=$(basename "$SHELL")

if [ "$CURRENT_SHELL" = "zsh" ]; then
    # 对于 zsh: 使用 ZDOTDIR 指向临时目录来加载 .zshrc
    TEMP_DIR=$(mktemp -d)
    TEMP_RC="$TEMP_DIR/.zshrc"
    cat > "$TEMP_RC" << 'EOF'
# 加载用户原有配置
[[ -f ~/.zshrc ]] && source ~/.zshrc

# 设置录制状态的提示符
PROMPT='%F{red}🔴 [Recording]%f %F{blue}%~%f %# '
EOF
    # 启动 zsh 并使用临时配置
    ZDOTDIR="$TEMP_DIR" zsh -i
else
    # 对于 bash
    TEMP_RC=$(mktemp)
    cat > "$TEMP_RC" << 'EOF'
# 加载用户原有配置
[[ -f ~/.bashrc ]] && source ~/.bashrc

# 设置录制状态的提示符
PS1="\[\033[1;31m\]🔴 [Recording]\[\033[0m\] \[\033[1;34m\]\w\[\033[0m\] \$ "
EOF
    # 启动 bash 并使用临时配置
    bash --rcfile "$TEMP_RC"
fi

echo ""
echo "╔════════════════════════════════════════════════════════════════╗"
echo "║  ⏹️  录制已停止                                                ║"
echo "╚════════════════════════════════════════════════════════════════╝"

echo ""
echo "✅ 抓包已停止！"
echo "📦 原始数据: $OUTPUT_MITM"
echo "📄 JSON数据: $OUTPUT_JSON"
